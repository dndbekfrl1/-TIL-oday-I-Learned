# 1.4 Http의 조상 (1) 전자메일

## client to server
* User-Agent: 클라이언트가 자신의 애플리케이션 이름을 넣는 곳. 

    curl 커맨드를 사용시 curl/7.48.0과 같은 문자열이 들어감

    서버는 이곳의 이름을 보고 응답을 전환하기도 함

    브라우저의 종류나 버전을 구분할 수 있음
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36

* Referer: 서버에서 참고하는 추가 정보

    클라이언트가 요청을 보낼 때 보고 있던 페이지의 URL을 보냄

    페이지의 참조원을 서버가 참조하는데 이용

* Authorization: 
  
  특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에 전달

## server to client
* Content-Type: 파일 종류 지정

    MIME 식별자 타입은 전자메일을 위해 만들어짐
* Content-Length: 바디 크기
    만약 다음 헤더에서 소개하는 압축이 이루어지는 경우 압축 후의 크기다 들어감

* Content-Encoding: 압축이 이루어진 경우 압축 형식 설명
* Date: 문서 날짜

## 헤더의 전송

```terminal

# 독자헤더 X-Text
curl --http1.0 -H "X-Text: Hello" http://localhost:18888

GET / HTTP/1.0
Host: localhost:18888
Connection: close
Accept: */*
User-Agent: curl/7.78.0
X-Text: Hello

```
curl 커맨드는 기본적으로 User-Agent와 Accept헤더를 전송하는 것을 알 수 있음
## MINE타입
파일의 종류를 구별하는 문자열
전자메일을 위해 만들어짐 

text/plain image/jpeg등의 포맷 식별자는 여기에서 정의됨

현재 웹 서버에서 HTML 보낼 시 서버의 응답 헤더에 다음과 같은 MINE타입 설정
```terminal
Content-Type: text/html; charset-utf-8
```

## Content-Type과 보안
콘텐츠 스니핑: MINE타입이 아닌 내용을 보고 파일 형식 추측

단점: 텍스트로만 표시돼야 하는 text/plain파일이 HTML과 자바스크립트가 적혀있으면 브라우저가 파일을 실행해버릴 가능성이 있음
-> 보안의 구멍이 됨

```terminal
X-Content-Type-Options: nosniff
```
서버가 위 헤더를 전송해 브라우저가 추측하지 않도록 방지 

## HTTP와 전자메일과의 차이
* 헤더+본문 구조는 같음
* HTTP 요청에는 선두에 '메서드+패스'행이 추가
* HTTP 응답에는 선두에 스테이터스 코드가 추가

간단히 말하면 HTTP통신은 고속으로 전자 메일이 왕복하는 것


# 1.5 Http의 조상 (2) 뉴스그룹
NNTP프로토콜으로부터 메서드와 스테이터스 코드 두 가지 기능을 도입함 

# 1.5.1 메서드 
HTTP는 파일 시스템 같은 설계 철학으로 만들어짐 
* GET
* HEAD
* POST
* PUT
* DELETE

HTML 폼에서는 GET과 POST만 지원

# 1.5.2 스테이터스 코드 
* 100 번대 - 처리가 계속 됨 
* 200 번대 - 성공했을 때의 응답 200은 OK로 정상 종료
* 300 번대 - 서버에서 클라이언트로의 명령. 오류는 아니고 정상 처리의 범주. 리다이렉트나 캐시 이용을 지시
* 400 번대 - 클라이언트가 보낸 요청에 오류
* 500 번대 - 서버 내부에서 오류 발생 

# 1.6 리디렉트 
서버가 브라우저에 대해 리디렉트하도록 지시하는 코드 
300 이외의 경우는 Location 헤더를 사용해 리디렉트할 곳을 서버에서 클라이언트로 전달함

* 영구적? 일시적? → 이동하는 이전 페이지가 이후에도 존재하는가?

    새 도메인을 얻어 서버의 콘텐츠를 이동 → 예전 페이지를 볼 필요 없음. 즉 영구적인 리디렉트

    HTTP로 운영되던 페이지를 HTTPS로 전환한 경우 → 예전 페이지를 볼 필요 없음. 즉 영구적인 리디렉트 

    점검 기간에만 요청을 관리 화면으로 리디렉트 → 점검이 끝나면 복구해 다시 활성화함. 즉 일시적인 리디렉트

* 메서드 변경? →

- 301/308: 요청된 페이지가 다른 장소로 이동 → 영구적으로 이동

    검색 엔진이 이 응답을 받으면 기존 페이지의 평가를 새로운 페이지로 계승.
    구글은 검색 엔진에 페이지 이동을 전하는 수단으로 301을 권장

- 302/307: 일시적인 이동. 모바일 전용 사이트로 이동 또는 관리 페이지 표시

- 303: 요청된 페이지에 반환할 콘텐츠가 없거나 원래 바환할 페이지가 따로 있을 때 그 쪽으로 이동시키려 사용  
    로그인한 후 원래 페이지로 이동하는 경우에 사용


~~(???)~~


# 1.7 URL 
URI: URN이라는 이름 부여 규칙 포함
함
URL: 문서 등의 리소스를 특정하는 수단 제공. 요컨대 주소

URN은 이름 그 자체이다.

웹 시스템에서 URI와 URL은 거의 같다. 
일반적으로 URL이 널리 사용됨

# 1.7.1 URL의 구조
https://comic.naver.com/index

- 구조 스키마://호스트명/경로
    - 스키마: https
    - 호스트명: comic.naver.com
    - 경로: index

URL 사양에 포함되는 모든 요소가 들어간 예제는 다음과 같다
- 스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리

스키마 해석은 브라우저의 책임

브라우저는 스키마를 보고 적절한 접속 방법을 택한다.
실제로 통신하는 곳은 호스트명으로 지정된 서버이다.

URL은 주소를 지정하는데 사용하지만, 동시에 사용자가 읽는 문장이다.

https://book.naver.com/bookdb/book_detail.naver?bid=20642480

왼쪽에서 오른쪽으로 갈수록 정보가 디테일해짐

구글의 검색 엔진은 URL에 단어가 포함된 경우 감색 순위에 조금 플러스되는 효과가 있다고 함

의미가 있는 URL을 만드는 것은 웹에 접근하는 사용자뿐만 아니라, HTTP기반 웹 API를 이용하는 프로그래머가 보더라고 프로그램을 이해하기 쉬워지는 장점이 있음

# 1.7.2 URL과 국제화
퓨니코드: 실제 웹 시스템에서 UTF-8 등 문자가 지원되는게 아니라, 정해진 규칙에 따라 반각 영숫자로 치환해 요청을 보냄

xn--으로 시작되는 문자열을 생성

# 1.8 바디 
HTTP에서 응답의 바디: 
단순하다. 
한 번 응답할 때마다 한 파일만 반환함
응답의 본체를 지정한 바이트 수만 읽으면 됨 (Content-Length 헤더로 지정함)


# 마치며
HTTP의 네가지 요소
- 헤더
- 바디
- 메서드와 경로
- 스테이터스 코드






